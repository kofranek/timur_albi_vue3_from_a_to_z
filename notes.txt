*********************************************
1. založení projektu
*********************************************
npm install -g @vue/cli
případně
npm update -g @vue/cli
vue --version

vue create . nebo: vue create adresář

v /public upravíme index.html na minimum
<!DOCTYPE html>
        <html lang="">
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width,initial-scale=1.0">
            <title>Vue 3 course</title>
          </head>
          <body>
            <div id="app"></div>
            <!-- built files will be auto injected -->
          </body>
        </html>

v src necháme pouze main.js
        import { createApp } from 'vue'
        createApp(App).mount('#app')

*********************************************************
2. Komponenta App, interpolace, posluchači událostí
*******************************************************
v main.js
        import { createApp } from 'vue'
        import App from './App'
        createApp(App).mount('#app')
v src vytvoříme App.vue:
        <template>
        </template>

        <script>
          export default {
          name: "App",
        </script>

        <style scoped>
        </style>

interpolace: {{proměnná či výraz }} zobrazení hodnoty v sekci template

        <div>likes count: <strong> {{ likes }}</strong></div>
        <div>dislikes count: <strong> {{ dilikes }}</strong></div>

v template vytvoříme strukturu komponenty:
    <template>
      <div>
        <button v-on:click="addLike">like</button>
        <button v-on:click="addDislike">dislike</button>
      </div>
      <div>
        <div>likes count: <strong> {{ likes }}</strong></div>
        <div>dislikes count: <strong> {{ dilikes }}</strong></div>
      </div>
    </template>

v <script> vytvoříme datové elementy a metody:

        <script>
        export default {
          name: "App",
          data() {
            return {
              likes: 0,
              dislikes: 0,
            }
          },
          methods: {
            addLike() {
              this.likes++
            },
            addDislike() {
              this.dislikes++
            },
          },
        }
        </script>

*********************************************************
3. Styly
*********************************************************

pokud chceme ovlivnit template (kde je použita třída "post"):

    <template>
      <div class="post">
        <div><strong>Název:</strong>Poznámka o JavaScriptu</div>
        <div><strong>Popis:</strong>JavaScript je univerzální programovací jazyk</div>
      </div>
      <div class="post">
        <div><strong>Název:</strong>Poznámka o JavaScriptu</div>
        <div><strong>Popis:</strong>JavaScript je univerzální programovací jazyk</div>
      </div>
      <div class="post">
        <div><strong>Název:</strong>Poznámka o JavaScriptu</div>
        <div><strong>Popis:</strong>JavaScript je univerzální programovací jazyk</div>
      </div>
    </template>

můžeme v sekci <style> uvést styly, které budou uplatněny v tomto a všech dceřinných komponentech:

    <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .post {
      padding: 15px;
      border: 2px solid teal;
      margin-top: 15px;
    }
    </style>

pokud je sekce označena klíčovým slovem "scoped" styly se týkají jen dané komponenty
    <style scoped>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .post {
      padding: 15px;
      border: 2px solid teal;
      margin-top: 15px;
    }
    </style>

*********************************************************
4. Vykreslování v cyklu - direktiva v-for
*********************************************************
v <template> vytvoříme cyklus v-for, kde iterujeme položku post v pole posts:

    <template>
      <div class="post" v-for="post in posts" >
        <div><strong>{{post.title}}</strong> {{post.body}}</div>
      </div>
    </template>

poznámka: správně bychom měli ke každé položce dát unikátní klíč "key":

v <script> v sekci data definujeme pole posts:
    data() {
        return {
          posts:[
            {id: 1, title: 'Hlavička dopisu 1', body: 'Obsah dopisu 1'},
            {id: 2, title: 'Hlavička dopisu 2', body: 'Obsah dopisu 2'},
            {id: 3, title: 'Hlavička dopisu 3', body: 'Obsah dopisu 3'},
            {id: 4, title: 'Hlavička dopisu 4', body: 'Obsah dopisu 4'},
          ]
        }
      },

********************************************************
5. Přidání nové položky
*********************************************************
V template vytvoříme formulář s dvěma vstupy a tlačítkem-
ve formuláři změníme klasické chování událosit submit (po stisku tlačíka),
které vede k obnovení stránky:
 <div class="app"
    <form @submit.prevent>
      <h4>Vytvoření položky</h4>
      <input class="input"
             type="text"
             placeholder="Název"
             v-bind:value="title"
             @input="inputTitle"
      >
      <input class="input"
             type="text"
             placeholder="Obsah"
             v-bind:value="body"
             @input="inputBody"
      >
      <button class="btn"
              @click.prevent="createPost"
      >
        Vytvořit položku
      </button>
    </form>
 </div>

V <input> máme dvě vazby:
jednou vazbou vstup propojíme s hodnotou proměnné title (resp body):
    v-bind:value="title"
    v-bind:value="body"

tyto proměnné vytvoříme v sekci data:
  data() {
    return {
      posts: [
        {id: 1, title: 'Hlavička dopisu 1', body: 'Obsah dopisu 1'},
        {id: 2, title: 'Hlavička dopisu 2', body: 'Obsah dopisu 2'},
        {id: 3, title: 'Hlavička dopisu 3', body: 'Obsah dopisu 3'},
        {id: 4, title: 'Hlavička dopisu 4', body: 'Obsah dopisu 4'},
      ],
      title: '',
      body: ''
    }
  },

tato vazba způsobí, že jakmile zmeníme hotnotu v proměnných title nebo body,
okamžitě se to projeví ve formulářových položkách input

Druhou vazbou propojíme událost input s obslužnými procedurami:
    @input="inputTitle"
    @input="inputBody"

v sekci method k nim napíšeme obslužné procedury:

    inputTitle(event) {
      this.title = event.target.value
    },
    inputBody(event) {
      this.body = event.target.value
    }

Obslužné procedury inputTitle a inputBody můžeme zaměnit přímým volání při
obsluze události @input:

            <input class="input"
                   type="text"
                   placeholder="Název"
                   v-bind:value="title"
                   @input="title=$event.target.value"
            >
            <input class="input"
                   type="text"
                   placeholder="Obsah"
                   v-bind:value="body"
                   @input="body=$event.target.value"
            >

Obsluha události tlačítka: událost click v tlačítku propojíme
s procedurou createPost

      <button class="btn" @click.prevent="createPost">
        Vytvořit položku
      </button>

   obslužná procedura createPost() přidá položku do pole posts:

    createPost() {
        const newPost = {
        id: Date.now(),
        title: this.title,
        body: this.body,
      }
        this.posts.push(newPost)
        this.title = ''
        this.body = ''
    },

Nesmíme zspomenout změnit ve formuláři form klasické chování událosit submit,
které vede k obnovení stránky:
        <form @submit.prevent>

Nakonec upravíme styly:

    <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .post {
      padding: 15px;
      border: 2px solid teal;
      margin-top: 15px;
    }

    .app {
       padding: 20px;
    }
    form {
      display: flex;
      flex-direction: column;
    }

    .btn {
      margin-top: 15px;
      align-self: flex-end;
      padding: 10px 15px;
      background: none;
      color: teal;
      border: 1px solid teal;
    }

    .input {
      width: 100%;
      border: 1px solid feal;
      padding: 10px 15px;
      margin-top: 15px;
    }
    </style>

********************************************************
6. Dekompozice, vytvoření znovupoužitelných komponent
*********************************************************

Vytvoříme novou složku ./src/components

a v ní komponenty PostForm a PostList

v rodičovském pomponentu App vyřežeme příslušné položky z <template> a přeneseme
je do kopmonent PostForm a PostList

Obdobně s App přeneseme i přislušne styly

V koponentě App tyto komponenty importujeme, a vytvoříme objekt components:

<template>
  <div class="app">
    <post-form/>
    <post-list/>
  </div>
</template>

<script>
  import PostForm from "@/components/PostForm";
  import PostList from "@/components/PostList";
  export default {
    components: {
      PostForm, PostList
    },
    ...


poznámka:
    components: {
      PostForm: PostForm,
      PostList: PostList
    },
  je totéž jako
    components: {
        PostForm, PostList
    },


********************************************************
7. Props - předávání dat do komponenty
*********************************************************

Deklarujeme Props v komponente PostList:

  <script>
  export default {
    name: "PostList",
    props: {
      posts_props: {
        type: Array,
        required: true
      }
    },
  }
  </script>

a pak se na hodnotu posts, která jako props přichází z rodičovnské
komponenty můžeme odvplávat:

  <template>
    <div class="post" v-for="post_props in posts">
    <div><strong>{{ post.title }}</strong> {{ post.body }}</div>
    </div>
  </template>

  Při jejím volání v rodičovské komponentě předáme jako argument pole posts

    <post-list :posts_props="posts "/>

app.vue                                       PostList.vue
   :posts_props = proměná --------------------->  post_props

                                               props: {
                                                  post_props: { type:xxx
                                                       default:xxx
                                                        required: true
                                                      }
                                               }


V komponentě PostForm odstraníme v button reakci na udílost click
    @click.prevent="createPost"
    zpětnou vazbu na rodičovsky komponent budeme dělat jinak

    vytvoříme lokální objekt

          post: {
            title: '',
            body: ''
          }
   a v template upravíme vzájemnou vazbu na tento objekt:

       <input class="input"
              type="text"
              placeholder="Název"
              v-bind:value="post.title"
              @input="post.title = $event.target.value"
       >
       <input class="input"
              type="text"
              placeholder="Obsah"
              v-bind:value="post.body"
              @input="post.body = $event.target.value"
       >

**********************************************************************
8. V-MODEL, @emit - výmena dat mezi rodičovským a dceřiným komponentem
**********************************************************************

V komponentě PostForm

    v-bind:value="post.title"                   input <------------- post.title
    @input="post.title = $event.target.value"   input -------------> post.title
a
    v-bind:value="post.body"                    input <------------- post.body
    @input="post.body = $event.target.value"    input -------------> post.body

nahradíme

    v-model="post.title"                       input <-------------> post.title
    v-model="post.body"                        input <-------------> post.body

tím uděláme oboustrannou vazbu na objekt post.


Button propojíme událostí clixck s metodou createPost:

    <button class="btn" @click="createPost">
      Vytvořit položku
    </button>

v ní vytvoříme nový post a pomocí $emit vytvoříme událost

$emit (název události, parametr, parametr....)

k ní můžeme připojit parametry a výsledek pošleme nahoru

  methods: {
    createPost() {
      this.post.id=Date.now()
      this.$emit('create',this.post, 'druhý parametr', 'třetí parametr')
      this.post = {
        title: '',
        body: ''
      }
    },

Rodičovský komponent se na tuto událost může podepsat a zavolat obslužnou proceduru:

    <post-form
        @create="createPost"
    />

    a obslužná procedura (v daném přípasde createPost) přijímá parametry z dceřinné komponenty:

  methods: {
    createPost(post, secondParameter, thirdParameter){
      console.log('post=', post)
      console.log('secondparameter=',secondParameter)
      console.log('thirdParameter=',thirdParameter)
    }
  },


   App.vue                                             PosForm.vue

                                                           @click="createPost"
                                                                       |
                                                                       |
                                                                       v
                                                               createPost(){
                                                               ....
 @create="obslužnáProcedura"<-------událost create--------- this.$emit('create',
                                                                 this.post,
                                                                 'druhý parametr',
                                                                 'třetí parametr')
                                                               ....
                                                               }


**********************************************************************
9. Další dekompozice - vytvořeni koponenty pro jednotlivou položku
**********************************************************************

Z komponenty PostList vytáhneme část, která se týká jedné položky -
vytvoříme položku PostItem:

<template>
  <div class="post">
    <strong>{{ post_props.title }}</strong> {{ post_props.body }}
  </div>
</template>

v ní deklarujeme props - post_props v němž komponente PostList pošle obsah
jednotlivé položky post:

<template>
  <div >
    <h4>Seznam položek</h4>
    <post-item
        v-for="post in posts_props"
        :post_props="post"
    />
  </div>
</template>


App                PostForm
@create <--post--- $emit(create, post)

App                           PostList                  PostItem
:posts_props -----posts-----> posta_props
                              :post_props ----post----> post_props


*********************************************************************
10. Odstranění prvku ze seznamu
**********************************************************************

1. Komponenta PostItem:
   nejprve upravíme trochu komponentu postItem, kde přidáme tlačítko:

    <template>
      <div class="post">
        <div>
          <div><strong>Název: </strong>{{ post_props.title }}</div>
          <div><strong>Obsah: </strong>{{ post_props.body }}</div>
        </div>
        <div class="post__btns">
          <button class="btn" @click="deletePost">Odstranit</button>
        </div>
      </div>
    </template>

   ostylizujeme:

    <style scoped>
    .post {
      padding: 15px;
      border: 2px solid teal;
      margin-top: 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    </style>

   vytvoříme obslužnou metodu deletePost:

    deletePost() {
       console.log('PostItem: post_props=', this.post_props)
       this.$emit('deletePost', this.post_props)
    }

 ... která emituje událostn deletePost a předává v argumentu post_props
 její rodičovský komponent

2. Komponenta PostList:

 od dceřiné komponenty post-item reaguje na událost deletePost:

     <div>
       <h4>Seznam položek</h4>
       <post-item
           v-for="post in posts_props"
           :post_props="post" :key="post.id"
           @deletePost="deletePost"
       />
     </div>

 obslužná procedura deletePost emituje událost clrPost a předává jako
 argument post

     deletePost(post) {
       console.log('PostList:delete:',post)
       this.$emit('clrPost', post)
     },

3. Komponenta App

 od dceřiné komponenty PostList reaguje na událost clrPost:

     ...
        <post-list :posts_props="posts" @clrPost="deletePost"/>
     ....

 její obslužná procedure deletePost:

    deletePost(post) {
      const idx = this.posts.findIndex((el) => {
        return (el.id === post.id)
      })
      this.posts.splice(idx,1)
    },

 odstraní ze seznamu posts příslušnou položku post, kterou dostane jako argument


*********************************************************************
11. Knihovna UI komponentů
**********************************************************************

vytvoříme složku /components/UI v níž budeme umisťovat komponenty
uživatelského rozhraní

v této složce vytvoříme komponentu MyButton (a do ní přeneseme i příslušný styl
třídy .bttn z komponenty PostForm

    <template>
    <button class="btn">
      <slot></slot>
    </button>
    </template>
    ...
    <style scoped>
    .btn {
      /*margin-top: 15px;*/
      padding: 10px 15px;
      background: none;
      color: teal;
      border: 1px solid teal;
    }
    </style>

Sloty <slots> slouží zde pro zobrazení příslušných popisů tlačítek
z instancí komponenty MyButton.

Instanci komponenty MyButton využijeme v komponentě PosForm místo původního
tlačítka <button>:

    <my-button
        @click="createPost"
        style="align-self: flex-end; margin-top: 15px"
    >
      Vytvořit položku
    </my-button>

    nezapomeneme ji importovat a registrovat (a také trochu upravit styl)

    <script>
    import MyButton from "@/components/UI/MyButton"

    export default {
      components: {MyButton},
      ...
      ...

Obdobně to uděláme v komponentě PostItem:

    ...
    <div class="post__btns">
      <my-button @click="deletePost">Odstranit</my-button>
    </div>
    ...
    <script>
    import MyButton from "@/components/UI/MyButton"
    export default {
      components: {MyButton},
      ...
      ...

Nyní mají všechnyx komponenty tlačítka stejný tvar

*********************************************************************
12. Podrobněji o v-model
**********************************************************************
vytvoříme komponentu MyButton

updatujeme nejprve /components/UI/index.js

import MyButton from "@/components/UI/MyButton"
import MyInput from "@/components/UI/MyInput"

export default [
    MyButton,
    MyInput
]

a vytvoříme komponentu components/UI/MyInput

    import MyButton from "@/components/UI/MyButton"
    import MyInput from "@/components/UI/MyInput"

    <template>
      <input
          class='input'
          type="text"
          :value="modelValue"      <--value vazbíme na modelValue
          @input="updateInput"
      >
    </template>

    <script>
    export default {
      name: "MyInput",
      props: {
        modelValue: [String, Number]   <--může být String nebo Number
      },
      methods: {
        updateInput(event) {
          console.log('event=',event.target.value)
          this.$emit('update:modelValue', event.target.value)
        }
      }
    }
    </script>


Komponenta MyInput je dceřinoou komponenou PostForm, kde jsou
vytvořeny dvě její instance

    <my-input type="text"
           placeholder="Název"
           v-model="post.title"
    />

    <my-input type="text"
           placeholder="Obsah"
           v-model="post.body"
    />
********************************************************
13. V_MODEL a atributami:
******************************************************
Ve vue 3 můžeme v-model spojit s pomnenovaným propsem value (nebo newvalue...)
to mimo jiné dává možnost použít v jedné komponentě více v-model-ů pro více props-ů
místo  v-model="post.title"
voláme v-model:value="post.title"

    RODIČOVSKÁ KOMPONENTA PosItem - v ní je instance dcečiné komponenty MyInput:

    <my-input type="text"
           placeholder="Název"
           v-model:value="post.title"     <--------místo v-model="post.title"
    />
    <my-input type="text"
           placeholder="Obsah"
           v-model:value="post.body"     <---------místo v-model="post-body"
    />

   DCEŘINÁ KOMPONENTA MyInput
   v dceřinné komponentě MyInput definujeme pojmebovaný props value (nebo newvalue...)

    <template>
      <input
          class='input'
          type="text"
          :value="value"           <---------- místo :value="modelValue"
          @input="updateInput"
      >
    </template>

    <script>
    export default {
      name: "MyInput",
      props: {
        value: [String, Number]        <--------- místo modelValue: [String, Number]
      },
      methods: {
        updateInput(event) {
          console.log('event=',event.target.value)
          this.$emit('update:value', event.target.value) <--- místo  this.$emit('update:modelValue',...
        }
      }
    }
    </script>

------------------------------------
oboustranná vazba s atributem v dceřinné komponentě

není-li v-model spojen s atributem (přes dvojtečku) je iplicitní
název atributu:

rodičovská komp.:        dceřinná komponenta (definovaná v jako props):
v-model         <---->   modelValue

props
 modelValue

nebo pojmenovaná

v-model:value   <-------> value
prosp
   value

v-model:newvalue <-------> newValue
props
   newValue

v-model:title   <-------> title
props
  title

v-model:body    <-------> body
props
  body

v-model:email   <-------> email
props
  email


this.$emit('update:modelValue', newVal)
this.$emit('update:newvalue', newVal)
this.$emit('update:title', newVal)
this.$emit('update:body', newVal)
this.$emit('update:email', newVal)


*********************************************************************
14. Odstranění prvku ze seznamu - s využitím $emit
**********************************************************************

nám už pracuje:

PosItem ---post.props--->PostList:

        <div class="post__btns">
          <my-button @click="deletePost">Odstranit</my-button>
        </div>
        ...
        props: {
            post_props: {
            type: Object,
            required: true,
            }
        ...
        deletePost() {
          this.$emit('deletePost', this.post_props)
        }


PostList ---post_props--->App:

        <post-item
            v-for="post in posts_props"
            :post_props="post"
            :key="post.id"
            @deletePost="deletePost"
        />
        ...
        props: {
          posts_props: {
            type: Array,
            required: true
          }
        ...
        deletePost(post) {
          console.log('PostList:delete:',post)
          this.$emit('clrPost', post)
        },

App:
        <post-list
            :posts_props="posts"
            @clrPost="deletePost"
        />
        ...
        deletePost(post) {
          const idx = this.posts.findIndex((el) => {
            return (el.id === post.id)
          })
          this.posts.splice(idx,1)
        },

můžeme to zkrátit ('$emit použijeme přímo v template)':

PosItem ---post.props--->PostList:

        <div class="post__btns">
            <my-button @click="$emit('deletePost',post_props)">Odstranit</my-button>
        </div>
        ...
        props: {
            post_props: {
            type: Object,
            required: true,
            }
        ...
        //deletePost() {
        //  this.$emit('deletePost', this.post_props)
        //}

PostList ---post_props--->App:

        <post-item
            v-for="post in posts_props"
            :post_props="post"
            :key="post.id"
            @deletePost="$emit('clrPost', post)"
        />
        ...
        props: {
          posts_props: {
            type: Array,
            required: true
          }
        ...
        //deletePost(post) {
        //  console.log('PostList:delete:',post)
        //  this.$emit('clrPost', post)
        //},

App:
        <post-list
            :posts_props="posts"
            @clrPost="deletePost"
        />
        ...

        deletePost(post) {
          // const idx = this.posts.findIndex((el) => {
          //   return (el.id === post.id)
          // })
          // this.posts.splice(idx,1)
          //***************************************************************
          // místo findIndex a splice použijeme k odstranění položky filter
          //***************************************************************
          this.posts = this.posts.filter(p =>p.id !== post.id)
        },


*********************************************************************
15. Podmíněné vykreslování
**********************************************************************

v-if, v-esle-if, v-else  (nezobrazené prvky se neobjeví v DOM)
příklad PostList:

    <template>
      <div v-if="posts_props.length>0">
        <h4>Seznam položek</h4>
        <post-item
            v-for="post in posts_props"
            :post_props="post"
            :key="post.id"
            @deletePost="$emit('clrPost', post)"
        />
      </div>
      <h4 v-else style="color: red">Nejsou žádné položky</h4>
    </template>

v-show (podmíněné vykrelování ale zachování prvků v DOMu)

    <template>
      <div v-show="posts_props.length>0">
        <h4>Seznam položek</h4>
        <post-item
            v-for="post in posts_props"
            :post_props="post"
            :key="post.id"
            @deletePost="$emit('clrPost', post)"
        />
      </div>
      <h4 v-show="posts_props.length===0" style="color: red">Nejsou žádné položky</h4>
    </template>

(v naší aplikaci použijeme v-if a v-else)

*********************************************************************
16. Modální okno
**********************************************************************

Vytvoříme znouvupoužitelnou komponentu modálního dialogového okna
@/components/UI/MyDialog

importujeme ho do @/components/UI/index.js a přidáme ho do pole komponent:

    import MyButton from "@/components/UI/MyButton"
    import MyInput from "@/components/UI/MyInput"
    import MyDialog from "@/components/UI/MyDialog"

    export default [
        MyButton,
        MyInput,
        MyDialog
    ]

Vytvoříme vlastní komponentu @/components/UI/MyDialog:
<!--<template>-->                    <---NEPOJMENOVANŸ v-model
    <!--  <div class="dialog"-->
    <!--       v-if="modelValue"-->  <---o viditelnosti rozhoduje hodnota v propsu ModelValue
    <!--       @click="hideDialog">-->
    <!--    <div @click.stop class="dialog__content">-->
    <!--      <slot></slot>-->
    <!--    </div>-->
    <!--  </div>-->
    <!--</template>-->
    <template>
      <div class="dialog"
          v-if="show"           <---o viditelnosti rozhoduje hodnota v propsu show
                                    (u nepojmenovaných by bylo v-if=modelValue)
          @click="hideDialog">  <---po kliknutí volá hideDialog
        <div @click.stop class="dialog__content"> <--@clik.stop zabráníme šíření eventu
          <slot></slot>                               když je kliknuto na obsah
                                                      uvnitř dialogového okna
        </div>
      </div>
    </template>

    <script>
    export default {
      name: "MyDialog",
      props: {
      // modelValue: {          <----- props modelValue (u pojmenovaných show :{... )
      //   type: Boolean,
      //   default: false,
      // }
        show: {                       <----- props show (u nepojmenovaných ModelValue :{... )
          type: Boolean,
          default: false,
        }
      },
      methods: {
        hideDialog() {            <--- obsluha kliknuto na dialogové okno
          // this.$emit('update:modelValue', false) <--událost onUpdate u nepojmenovaných
          this.$emit('update:show', false)  <---emitujem událost a nastavení parametru na false
                                                tím rovnou nastavíme hodnotu propsu na false
                                                (u nepojmenovaných this.$emits('update:modelValue',false))
        }
      }
    }
    </script>
    <style scoped>
    .dialog {
      top: 0;        <---okno je po celé ovrazovce
      bottom: 0;
      right: 0;
      left: 0;
      background: rgba(0,0,0,0.5); <---okno je tmavé a průzračnost 0.5
      position:fixed;
      display: flex;
    }
    .dialog__content {
      margin:auto;
      background:white;
      border-radius:12px;
      min-height:50px;
      min-width:300px;
      padding:20px;
    }
    </style>

Volání komponenty v rodičovské komponentě App:

    <template>
      <div class="app">
        <h1>Dialog s položkami</h1>
        <my-button
            @click="showDialog"     <--- tlačítko otevře dialog. okno
            style="margin:15px 0;"
        >Vytvořit položku
        </my-button>
        <my-dialog v-model:show="dialogVisible">  <---oboustranná vazba, props show
                                                      pojmenovaný v-model:show,
                                                      (u nepojmenovaných by bylo
                                                      v-model="dialogVisible)
          <post-form                   <--post-form dáme dovnitř my.button
              @create="createPost"
          />
        </my-dialog>
        ...
      </div>
    </template>

    <script>
    import PostForm from "@/components/PostForm";
    import PostList from "@/components/PostList";

    export default {
      ....
      data() {
        return {
         ....
          dialogVisible: false, <--- vazba na hodnotu props v-model:show
        }
      },
      methods: {
        createPost(post) {
          this.posts.push(post)
          this.dialogVisible = false    <--- po zadání položky uzavře dial. okno
        },
        ...
        showDialog() {             <--- obsluha otevření dialog. okna
          this.dialogVisible = true
        },

      }
    }
    </script>

****************************************************************
17. Modifikátory v-model
****************************************************************
v-model.trim
    Modifikátor .trimautomaticky ořezává bílé znaky ze vstupů uživatele.
    Můžeme to použít napsáním:
    <input v-model.trim="msg" />
v-model.number
    Modifikátor .number nám umožňuje automaticky převést vše, co je zadáno, na číslo.
    Například můžeme napsat:
    <input v-model.number="numApples" type="number" />
v-model.lazy
    Modifikátor .lazy se po každé události v-modelsynchronizuje se stavem instance Vue .change
    Ve výchozím nastavení se v-modelsynchronizuje se stavem po každé inputudálosti.
    <input v-model.lazy="msg" />

****************************************************************
18. Práce se serverem - {JSON} Placeholser aknihovna axios
****************************************************************

využijeme službu {JSON} Placeholder
     https://jsonplaceholder.typicode.com/

nainstalujeme knihovnu axios
     npm install axios

pokud zavoláme (v editačním řádku prohlížeče) službu {JSON} Placeholder:
   https://jsonplaceholder.typicode.com/posts?_limit=10
   dostaneme 10 postů

v komponentě App.vue:

    <template>
    ...
        <my-button @click="fetchPosts">   <--vytvoříme tlačítko
          dostat posty
        </my-button>
    ...
    </template>

    <script>
    import PostForm from "@/components/PostForm";
    import PostList from "@/components/PostList";
    import axios from 'axios'            <--- importujeme 'axios'

    export default {
      ...
      data() {
        return {
          posts: [],      <-- položku posts dáme prázdnou (vyhodíme původní mock-up posty)
          ...
        }
      },
      methods: {
        ....
        async fetchPosts() {     <-- asyns obslužná procedura
          try {    <---v try bloku voláme await axios get(url)
            const response = await axios.get('https://jsonplaceholder.typicode.com/posts?_limit=10')
            console.log(response)  <-- seznam postů bude v response
            this.posts = response.data
            //console.log(this.posts)
          } catch (e) {
            alert('chyba čtení')
          }
        }
      }
    }
    </script>

nyní dostáváme seznam postů ze serveru

****************************************************************
19. Životní cyklus komponenty, hook mounted
****************************************************************

https://vuejs.org/guide/essentials/lifecycle.html

beforeCreate()
-> vytvoření (inicializace Option Api)
created()
-> kompilace template (pokud není předkompilován)
beforeMount()
-> montování (vykreslování a vytvoření uzlu DOM)
mounted()

beforeUpdate()
-> obnova (updatování při změně dat )
afterUpdate()

beforeUnmount()
-> zánik
unmounted()

v App.vue odstraníme tkačítko vyvolávající nastení postů,
    <template>
    ...
        <my-button @click="fetchPosts">   <--odstraníme toto tlačítko
          dostat posty
        </my-button>
    ...
    </template>
a posty budeme nyní načítat hned po načtení stránky.
Využijeme proto hook mounted:

    <script>
    ...
    export default {
      methods: {
        ...
        async fetchPosts() {
          try {
            const response = await axios.get('https://jsonplaceholder.typicode.com/posts?_limit=10')
            console.log(response)
            this.posts = response.data
            console.log(this.posts)
          } catch (e) {
            alert('chyba čtení')
          }
        },
      },
      mounted() {               <-- hook mounted
        console.log('mounted')
        this.fetchPosts()
      },
    }
    </script>

****************************************************************
20. Indikátor načítání dat
****************************************************************

V komponentě App.vue

    <template>
        ...
        <post-list
            :posts_props="posts"
            @clrPost="deletePost"
            v-if="!isPostsLoading"   <--skryto když běží načítání dat
        />
        <div v-else>Běží načítání dat</div>  <--zobrazí se při načítání dat
        ...
    </template>

    <script>
    ...
      data() {
        return {
          ....
          isPostsLoading: false,   <--indikátor načítání dat
        }
      },
      methods: {
        ...
        async fetchPosts() {
          try {
            this.isPostsLoading=true    <-- než spustíme načítání dat

            setTimeout(async () => {    <-- zavedem setTimeout kvůli viditelnému zpoždění při načítání
              const response = await axios.get('https://jsonplaceholder.typicode.com/posts?_limit=10')
              this.posts = response.data
              this.isPostsLoading = false
              console.log('Solving error: timeout isPostsLoading',this.isPostsLoading)
            }, 1000)
          } catch (e) {
            alert('chyba čtení')
          } finally {
             //this.isPostsLoading = false //ERROR
             console.log('ERROR: this.isPostsLoading = false ERROR')
          }
        },
      }, <--konec methods
      mounted() {
        //console.log('mounted')
        this.fetchPosts()        <--načítání postů vpláme po namontování
      },
    }
    </script>

******************************
Oprava chyby
*******************************
        async fetchPosts() {
          try {
            this.isPostsLoading=true    <-- než spustíme načítání dat

            setTimeout(async () => {    <-- zavedem setTimeout kvůli viditelnému zpoždění při načítání
              ....
              this.isPostsLoading = false  <-- nastaví se po 1000 msek (je v callback que)
            }, 1000)
          } catch (e) {
            alert('chyba čtení')
          } finally {
             //this.isPostsLoading = false //ERROR  <-- nastaví se hned (je v Call Stack)
             console.log('ERROR: this.isPostsLoading = false ERROR')
          }
        },


****************************************************************
21. Rozbalovací seznam
****************************************************************

Vytvoříme rozbalovaací seznam pro třídění příspěvků

nejdříve v @/components/UI vytvoříme nový soubor MySelect.vue

    <template>
      <select
          style="cursor: pointer"   <-- aby se změnil kurzor na klikací
          v-model="modelValue"      <-- alternetiva: v-model="vysledek"
          @change="changeOption">
        <option disabled value="">Zvolte ze seznamu</option> <--disablovaná opce
        <option                     <-- zde vypíášeme všechny option
            v-for="opt in options"  <-- budeme hledat v cylku v options
            :key="opt.value"
            :value="opt.value"
        >
          {{ opt.name }}         <-- budeme vypisovat obsah položky name
        </option>
      </select>
    </template>

    <script>
    export default {
      name: "MySelect",
      props: {              <-- dva propsy modelValue a options
        modelValue: {       <-- alternativa vysledek: {
          type: String
        },
        options: {
          type: Array,
          default: () => []
        }
      },
      methods: {
        changeOption(event) {
           this.$emit('update:modelValue', event.target.value)
       <-- this.$emit('update:vysledek',... (alternativa)
        }
      }
    }
    </script>

Upravíme @/components/UI/index.js:

    import MyButton from "@/components/UI/MyButton"
    import MyInput from "@/components/UI/MyInput"
    import MyDialog from "@/components/UI/MyDialog"
    import MySelect from "@/components/UI/MySelect"; <-- doplníme import

    export default [
        MyButton,
        MyInput,
        MyDialog,
        MySelect                      <--přidáme MySelect
    ]

komponentu voláme v rodičovnské komponentě App.vue:
(kde trochu upravíme volání tlačítka a rozbalovacího seznamu
aby byli v jednom řádku - proto je zahrneme do společného div)

App.vue:

    <template>
      <div class="app">
        ....
        <div class="app__btns">
          <my-button
              @click="showDialog"
                  <-- zde jsme odstranili style="margin: 15px, 0;"
                  <-- to přeneseme do stylů třídy app_btns
          >
            vytvořit položku
          </my-button>
          <my-select
              v-model="selectedSort"  <--alternativa v-model:vysledek
              :options="sortOptions"
          />
        </div>
        ...
    </template>

    <script>
    ...
    export default {
      data() {
          ...
          selectedSort: '',
          sortOptions: [
            {value: 'title', name: 'Podle názvu'},
            {value: 'body', name: 'Podle obsahu'}
          ]
        }
      },
      ...
    }
    </script>

    <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .app {
      padding: 20px;
    }
    .app__btns {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;    <-- upravíme styl
    }
    </style>


NASTAVENÍ KURZORU NAD KLIKACÍMI OBJEKTY
(tj. nad tlačítky, nad rozbalovacím seznamem
a nad okolní plochou modálního okna  - kliknutí na ní okno zavíráme)

Tlačítko - MyButton.vue:

    <style scoped>
    .btn {
      /*margin-top: 15px;*/
      padding: 10px 15px;
      background: none;
      color: teal;
      border: 1px solid teal;
      cursor: pointer;           <--- klikací kurzor
    }
    </style>

Dialogové okno - MyDialog.vue:

    <template>
      <div class="dialog"
           v-if="show"
           style="cursor:pointer"    <--okolí modálního okna - klikací kurzor
           @click="hideDialog">
        <div @click.stop
           class="dialog__content"
           style="cursor: default">    <--vlastní modální okno - defaultní kurzor
          <slot></slot>
        </div>
      </div>
    </template>

rozbalovací seznam - MySelect.vue

    <template>
      <select
          style="cursor: pointer"   <-- aby se změnil kurzor na klikací
          v-model="modelValue"
          @change="changeOption">
        <option disabled value="">Zvolte ze seznamu</option> <--disablovaná opce
        <option
            v-for="opt in options"
            :key="opt.value"
            :value="opt.value"
        >
          {{ opt.name }}
        </option>
      </select>
    </template>

****************************************************************
22. Watch a Computed
****************************************************************

Watch - sledují hodnotu a mění se při změně hodnoty (analog useEffect z Reactu)
Computed - za běhu vypočítává hodontu položky - vrací hodnotu jako funkce a
zapamatují si ji, pokud se nezmění vstupy (analog use Memo z Reactu)

příklad watch v App.vue

  watch: {
    selectedSort(newValue) {  //když se mění hodnpta
       console.log(newValue)
     },
    dialogVisible(newValue) {
      console.log(newValue)
    }
  }


Watch s polem nebo objektem

 sledujeme např. v PostForm.vue objekt post:
   data() {
     return {
       post: {
         title: '',
         body: ''
       }
     }
   },
 ...

  watch: {
    post: {  //pracuje to jak s objekty tak i s poli
      handler(newVal) {           <--musíme mít handlet
        console.log(newVal)
      },
      deep: true                  <--a položku deep:true
    }
  }

Setřídění položek pomocí watch v App.vue
******************************************
  <post-list
      :posts_props="posts"
       @clrPost="deletePost"
        v-if="!isPostsLoading"
  />
  ...
  data() {
    return {
      posts: [],                 <-- pole posts, zaplňované při načítíní ze serveru
      dialogVisible: false,
      isPostsLoading: false,
      selectedSort: '',         <-- vybraná položka z rozbalovacího seznamu
      sortOptions: [
        {value: 'title', name: 'Podle názvu'},
        {value: 'body', name: 'Podle obsahu'}
      ]
    }
  },

  watch: {
    selectedSort(newValue) {  //když se mění hodnpta
       console.log(newValue)
       this.posts.sort((post1, post2) => {
         return post1[this.selectedSort]?.localeCompare(post2[this.selectedSort])
       })
     },
     ...
  }

  alternativně - místo k selectedSort použijeme newValue:

  watch: {
    selectedSort(newValue) {  //když se mění hodnpta
       console.log(newValue)
       this.posts.sort((post1, post2) => {
         //return post1[this.selectedSort]?.localeCompare(post2[this.selectedSort])
         // místo k položce selectedSort se obracíme k newValue
         return post1[newValue]?.localeCompare(post2[newValue])
       })
     },
     ...
  }

Setřídění položek pomocí computed vlastností - v App.vue
*********************************************************

  <post-list
      :posts_props="sortedPosts"    <-- místo :posts_props="posts"
      @clrPost="deletePost"
      v-if="!isPostsLoading"
  />

  computed: {
    sortedPosts() {
      return [...this.posts].sort((post1, post2) =>
          post1[this.selectedSort]?.localeCompare(post2[this.selectedSort]))
    }
  },

****************************************************************
23. Animace transition group
****************************************************************

iz dokumentace:
https://vuejs.org/guide/built-ins/transition-group.html#transitiongroup

v PostList.vue uzavřeme <post-item> do <transition-group>

    <template>
      <div v-if="posts_props.length>0">
        <h4>Seznam položek</h4>
        <transition-group name="list">
          <post-item
              v-for="post in posts_props"
              :post_props="post"
              :key="post.id"
              @deletePost="$emit('clrPost', post)"
          />
        </transition-group>

      </div>
      <h4 v-else style="color: red">Nejsou žádné položky</h4>
    </template>


a z dokumentace vezmeme třídy
Enter / Leave Transitions
a Move Transitions a umístíme je do scope -
a zadáme atriubut name v <transition-group name="list">

    <style scoped>
    .list-enter-active,
    .list-leave-active {
      transition: all 0.5s ease;
    }

    .list-enter-from,
    .list-leave-to {
      opacity: 0;
      transform: translateX(30px);
    }

    .list-move, /* apply transition to moving elements */
    .list-enter-active,
    .list-leave-active {
      transition: all 0.5s ease;
    }

    .list-enter-from,
    .list-leave-to {
      opacity: 0;
      transform: translateX(30px);
    }

    /* ensure leaving items are taken out of layout flow so that moving
       animations can be calculated correctly. */
    .list-leave-active {
      position: absolute;
    }
    </style>

a případně můžeme styly upravovat (třeba translateX na translateY apod.)

****************************************************************
24. Vyhledávání v položkách. Redesign MyInput
****************************************************************

nejprve uděláme ve App.vue nový input:

    <template>
      <div class="app">
        <h1>Dialog s položkami</h1>
        <my-input
            type="text"
            v-model:value="searchQuery"        <-- načítáme do SearchQuery
            placeholder="Název hledané položky..."
        />
        ...
      </div>
    </template>

v App.vue definujeme novou modeliku searchQuery:

    data() {
      return {
        posts: [],
        dialogVisible: false,
        isPostsLoading: false,
        selectedSort: '',
        searchQuery: '',      <--nová proměnná
        sortOptions: [
          {value: 'title', name: 'Podle názvu'},
          {value: 'body', name: 'Podle obsahu'}
        ]
      }
    },

v App.vue definujeme novou computed vlastnost sortedAndSearchedPosts
  - využijeme přitom tu předchozí sortedPosts:

    computed: {
      sortedPosts() {
        return [...this.posts].sort((post1, post2) =>
            post1[this.selectedSort]?.localeCompare(post2[this.selectedSort]))
      },
      sortedAndSearchedPosts() {
        console.log('this.searchQuery', this.searchQuery)
         return this.sortedPosts
             .filter(post =>
                 post.title.toLowerCase().includes(this.searchQuery.toLowerCase()))
      }
    },

v App.vue v <post-list> volaný porops místo :posts_props="sortedPosts"
navážeme na novou computed proměnnou :posts_props="sortedAndSearchedPosts"

    <template>
      <div class="app">
        <h1>Dialog s položkami</h1>
        <my-input
            type="text"
            v-model:value="searchQuery"    <-- input načítáme do SearchQuery
            placeholder="Název hledané položky..."
        />
    ....
    <!--    <post-list-->
    <!--        :posts_props="sortedPosts"-->
    <!--        @clrPost="deletePost"-->
    <!--        v-if="!isPostsLoading"-->
    <!--    />-->
        <post-list
            :posts_props="sortedAndSearchedPosts"  <-- nová vazba
            @clrPost="deletePost"
            v-if="!isPostsLoading"
        />
        <div v-else>Běží načítání dat</div>
      </div>
    </template>


REDESIGN MyInput.vue
*************************************

REDESIGN MyInput

    <template>
      <input
          class='input'
          type="text"
          :modelValue="value"    <-- místo :value

          @input="updateInput"
      >
    </template>

    <script>
    export default {
      name: "MyInput",
      props: {
        value: [String, Number]
      },
      methods: {
        updateInput(event) {
          this.$emit('update:modelValue', event.target.value)
          //<-- misto 'update:value'
        }
      }
    }

úprava volání MyInput v App.vue a v PostForm.vue:

App.vue:
    <template>
      <div class="app">
        <h1>Dialog s položkami</h1>
        <my-input
            type="text"
            v-model="searchQuery"   <-- místo v-model:value=...
            placeholder="Název hledané položky..."
      ...
    </template>


PostForm.vue:
<template>
      <form @submit.prevent>
        <h4>Vytvoření položky</h4>
        <my-input type="text"
                  placeholder="Název"
                  v-model="post.title" <-- místo v-model:value
        />
        <my-input type="text"
                  placeholder="Obsah"
                  v-model="post.body" <--místo v-model:value
        />
       ....
      </form>
    </template>

****************************************************************
25. Stránkování. Výstup podle čísla stránky
****************************************************************

opět využijeme službu {JSON} Placeholder
     https://jsonplaceholder.typicode.com/
     výpis 100 postů:
     https://jsonplaceholder.typicode.com/posts

     výpis prvních 10 postů:
     https://jsonplaceholder.typicode.com/posts?_limit=10

     výpis 10 postů, na straně 3:
     https://jsonplaceholder.typicode.com/posts?_limit=10&_page=3

     https://jsonplaceholder.typicode.com/posts?_limit=10&_page=11
       výstup []

v App.vue

    <template>
      <div class="app">
        ....
        <post-list       <-- načítáme posty při načtení stránky (hook mounted)
            :posts_props="sortedAndSearchedPosts"  <-- computed vlastnost (pole postů)
            @clrPost="deletePost"
            v-if="!isPostsLoading"
        />
        <div v-else>Běží načítání dat</div>
        <div class="page__wrapper">  <-- třídu "page__wraper" deklarujeme v pages
          <div v-for="page in totalPages" <--budeme vypisovat pořadí stránek
               :key="page"
               class="page"    <-- třídu "page" deklarujeme v styles
          >
            {{ page }}
          </div>
        </div>
      </div>
    </template>

    <script>
    ...
    export default {
      ...
      data() {
        return {
          posts: [],  <--pole postů (načte se v fetchPosts)
          ...
          page: 1,  <-- pořadí stránky
          limit: 10,  <-- počet postů na stránku
          totalPages: 0,  <-- celkový počet stránek
          ...
        }
      },
      methods: {
        ...
        async fetchPosts() {  <-- upravíme načítání postů ze serveru
          try {
            this.isPostsLoading = true
            console.log('fetchPosts: this.isPostsLoading = true')
            setTimeout(async () => {
              //const response = await axios.get('https://jsonplaceholder.typicode.com/posts?_limit=10')
              //původně se načetlo prvních 10 postů
              const response = await axios
                  .get('https://jsonplaceholder.typicode.com/posts',
                    params: {  <-- specifikace požadavků
                      _page: this.page,    <-- pořadí stránky
                      _limit: this.limit,  <-- počet postů na stránku
                    }
                  })
              console.log('total posts', response.headers['x-total-count'])
              this.totalPages = Math.ceil(response.headers['x-total-count'] / this.limit)
              console.log('totalPages', this.totalPages)
              this.posts = response.data

              this.isPostsLoading = false
              console.log('Solving error: timeout isPostsLoading',this.isPostsLoading)

            }, 1000)
          } catch (e) {
            alert('chyba čtení')
          } finally {
            //this.isPostsLoading = false //ERROR
            console.log('ERROR: this.isPostsLoading = false ERROR')
          }
        },
      },
      mounted() {
        //console.log('mounted')
        this.fetchPosts()   <-- po načtení sgtránky volám e fetch
      },
      computed: {
        sortedPosts() {
          return [...this.posts].sort((post1, post2) =>
              post1[this.selectedSort]?.localeCompare(post2[this.selectedSort]))
        },
        sortedAndSearchedPosts() {  <--načte pole postů z posts pro <post-list>
          //console.log('this.searchQuery', this.searchQuery)
          return this.sortedPosts
              .filter(post =>
                  post.title.toLowerCase().includes(this.searchQuery.toLowerCase()))
        }
      },
      ...
    }
    </script>

    <style>
    ...

    .page__wrapper {   <-- nově deklarovaná třída
      display: flex;   <-- stránky se budou vypisovat v řádce
      margin-top: 15px;  <--odstup nahoře
    }

    .page {     <--nově deklarovaná třída
      border: 1px solid black;  <--rámeček
      padding: 10px;            <--vnitřní odstupy
    }
    </style>

Výsledkem je seznam 10 čísel stránek v rámečcích
zatím se ale po načtení vypisuje pouze 10 prvních postů

**********************************************************************
26. Dynamický binding tříd a stylů. Volba načtení podle zadané stránky
**********************************************************************

App.vue:
    ...
    <div class="page__wrapper">
      <div v-for="pageNumber in totalPages"
           :key="pageNumber"
           class="page"
           :class="{               <-- dynamicky binding třídy
             'current-page': page===pageNumber
           }"
           @click="changePage(pageNumber)"  <-- změna stránky
      >
        {{ pageNumber }}
      </div>
    </div>
    ..

      methods: {
        ....
        changePage(pageNumber) {  <-- obslužná procedura
          this.page = pageNumber
          this.isPostsLoading = true //zobrazování indikátoru načítání stránky
          console.log('Solving ERROR: change page this.isPostsLoading',this.isPostsLoading)

          //this.fetchPosts()     <-- jedna z možností
          //místo fetchPosts použijeme watch
        },
      ....
      },
      watch: {
        page() {      <-- jimá možnost - zadáno spíše jako jako cvičení
          //page(newValue){
          //console.log('page=',newValue)
          //zavolá se když se změní stránky (nemusíme vypisovat hodnotu)
          this.fetchPosts()
        },

    <style>
     ...
    .page {
      border: 1px solid black;
      padding: 10px;
      cursor: pointer;    <--přidán klikací kurzor
    }

    .current-page {
      border: 2px solid teal;  <--vybraná stránka
    }
    </style>

pro lepší čitelnost změn v PostItem přidáme vypisování id postu

    <div>
      <div>{{post_props.id}}</div>    <-- přidáno vypisování id
      <div><strong>Název: </strong>{{ post_props.title }}</div>
      <div><strong>Obsah: </strong>{{ post_props.body }}</div>
    </div>

**********************************************************************
27. Dynamická paginace. Nekonečná páska. Intersection API
**********************************************************************

Na konci načítaného souboru postů umístíme nový div, s třídou observer
a budeme detekovat překřížení s viditelným viewpoitem obrazovky
Použijeme rozhhraní Intersectiion API

https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API


v App.Vue:

    <template>
        ...
        <div v-else>Běží načítání dat</div>
        <div class="observer"></div>         <--nový div s třídou observer

        <!--    <div class="page__wrapper">-->           <--- odstraníme
        <!--      <div v-for="pageNumber in totalPages"-->
        <!--           :key="pageNumber"-->
        <!--           class="page"-->
        <!--           :class="{-->
        <!--             'current-page': page===pageNumber-->
        <!--           }"-->
        <!--           @click="changePage(pageNumber)"-->
        <!--      >-->
        <!--        {{ pageNumber }}-->
        <!--      </div>-->
        <!--    </div>-->
      </div>
    </template>
    ...
    <script>
    ....
     async loadMorePosts() {   <--zkopírujeme fetch a upravíme
       try {
         this.isPostsLoading = true
         console.log('fetchPosts: this.isPostsLoading = true')
         setTimeout(async () => {
           //const response = await axios.get('https://jsonplaceholder.typicode.com/posts?_limit=10')
           const response = await axios
               .get('https://jsonplaceholder.typicode.com/posts', {
                 params: {
                   _page: this.page,
                   _limit: this.limit,
                 }
               })
           console.log('total posts', response.headers['x-total-count'])
           this.totalPages = Math.ceil(response.headers['x-total-count'] / this.limit)
           console.log('totalPages', this.totalPages)
           this.posts = [...this.posts, ...response.data] <--upraveno
           this.isPostsLoading = false
           console.log('Solving error: timeout isPostsLoading', this.isPostsLoading)
         }, 1000)
       } catch (e) {
         alert('chyba čtení')
       } finally {
         //this.isPostsLoading = false //ERROR
         console.log('ERROR: this.isPostsLoading = false ERROR')
       }
       ...
       mounted() {
         //console.log('mounted')
         this.fetchPosts()
         const options = {
           rootMargin: '0px',
           threshold: 1.0
         }
         const callback = function (entries, options){
         }
         const observer = new IntersectionObserver(callback, options);

       },
        ...

        watch: {
            // page() {
            //   //page(newValue){
            //   //console.log('page=',newValue)
            //   //zavolá se když se změní stránky (nemusíme vypisovat hodnotu)
            //   this.fetchPosts()
            // },
         ...
        }
    </script>
    <style>
    .observer {
      height: 30px;
      background: green;

    }
    </style>
